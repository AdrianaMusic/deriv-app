{"version":3,"sources":["webpack:////home/circleci/project/packages/components/node_modules/memoize-one/dist/memoize-one.esm.js","webpack:////home/circleci/project/packages/components/node_modules/react-window/dist/index.esm.js"],"names":["areInputsEqual","newInputs","lastInputs","length","i","resultFn","isEqual","lastThis","lastResult","lastArgs","calledOnce","newArgs","_i","arguments","this","apply","now","performance","Date","cancelTimeout","timeoutID","cancelAnimationFrame","id","requestTimeout","callback","delay","start","requestAnimationFrame","tick","call","size","cachedRTLResult","getRTLOffsetType","recalculate","outerDiv","document","createElement","outerStyle","style","width","height","overflow","direction","innerDiv","innerStyle","appendChild","body","scrollLeft","removeChild","defaultItemKey","_ref","columnIndex","data","rowIndex","createGridComponent","_ref2","_class","_temp","getColumnOffset","getColumnStartIndexForOffset","getColumnStopIndexForStartIndex","getColumnWidth","getEstimatedTotalHeight","getEstimatedTotalWidth","getOffsetForColumnAndAlignment","getOffsetForRowAndAlignment","getRowHeight","getRowOffset","getRowStartIndexForOffset","getRowStopIndexForStartIndex","initInstanceProps","shouldResetStyleCacheOnItemSizeChange","validateProps","_PureComponent","Grid","props","_this","_instanceProps","_resetIsScrollingTimeoutId","_outerRef","state","instance","isScrolling","horizontalScrollDirection","initialScrollLeft","scrollTop","initialScrollTop","scrollUpdateWasRequested","verticalScrollDirection","_callOnItemsRendered","overscanColumnStartIndex","overscanColumnStopIndex","overscanRowStartIndex","overscanRowStopIndex","visibleColumnStartIndex","visibleColumnStopIndex","visibleRowStartIndex","visibleRowStopIndex","onItemsRendered","_callOnScroll","onScroll","_getItemStyle","_style","_this$props","columnWidth","rowHeight","itemStyleCache","_getItemStyleCache","key","hasOwnProperty","position","top","_","__","___","_onScroll","event","_event$currentTarget","currentTarget","clientHeight","clientWidth","scrollHeight","scrollWidth","setState","prevState","calculatedScrollLeft","Math","max","min","calculatedScrollTop","_resetIsScrollingDebounced","_outerRefSetter","ref","outerRef","current","_resetIsScrolling","getDerivedStateFromProps","nextProps","validateSharedProps","_proto","prototype","scrollTo","_ref3","undefined","scrollToItem","_ref4","_ref4$align","align","_this$props2","columnCount","rowCount","_this$state","scrollbarSize","div","offsetWidth","getScrollbarSize","estimatedTotalHeight","horizontalScrollbarSize","verticalScrollbarSize","componentDidMount","_this$props3","_callPropsCallbacks","componentDidUpdate","_this$state2","componentWillUnmount","render","_this$props4","children","className","innerRef","innerElementType","innerTagName","itemData","_this$props4$itemKey","itemKey","outerElementType","outerTagName","useIsScrolling","_this$_getHorizontalR","_getHorizontalRangeToRender","columnStartIndex","columnStopIndex","_this$_getVerticalRan","_getVerticalRangeToRender","rowStartIndex","rowStopIndex","items","_rowIndex","_columnIndex","push","estimatedTotalWidth","WebkitOverflowScrolling","willChange","pointerEvents","_this$props5","_this$_getHorizontalR2","_overscanColumnStartIndex","_overscanColumnStopIndex","_visibleColumnStartIndex","_visibleColumnStopIndex","_this$_getVerticalRan2","_overscanRowStartIndex","_overscanRowStopIndex","_visibleRowStartIndex","_visibleRowStopIndex","_this$state3","_horizontalScrollDirection","_scrollLeft","_scrollTop","_scrollUpdateWasRequested","_verticalScrollDirection","_this$props6","overscanColumnCount","overscanColumnsCount","overscanCount","_this$state4","overscanCountResolved","startIndex","stopIndex","overscanBackward","overscanForward","_this$props7","overscanRowCount","overscanRowsCount","_this$state5","defaultProps","_ref5","_ref6","rowMetadataMap","estimatedRowHeight","lastMeasuredRowIndex","totalSizeOfMeasuredRows","itemMetadata","offset","columnMetadataMap","estimatedColumnWidth","lastMeasuredColumnIndex","getItemMetadata","itemType","index","instanceProps","itemMetadataMap","itemSize","lastMeasuredIndex","findNearestItem","findNearestItemBinarySearch","findNearestItemExponentialSearch","high","low","middle","floor","currentOffset","itemCount","interval","scrollOffset","estimatedTotalSize","maxOffset","minOffset","round","VariableSizeGrid","resetAfterColumnIndex","shouldForceUpdate","resetAfterIndices","resetAfterRowIndex","_ref6$shouldForceUpda","forceUpdate","_ref7","defaultItemKey$1","createListComponent","getItemOffset","getEstimatedTotalSize","getItemSize","getOffsetForIndexAndAlignment","getStartIndexForOffset","getStopIndexForStartIndex","List","scrollDirection","initialScrollOffset","overscanStartIndex","overscanStopIndex","visibleStartIndex","visibleStopIndex","layout","_offset","isHorizontal","_onScrollHorizontal","_onScrollVertical","_event$currentTarget2","validateSharedProps$1","_this$_getRangeToRend","_getRangeToRender","_index","_this$_getRangeToRend2","_overscanStartIndex","_overscanStopIndex","_visibleStartIndex","_visibleStopIndex","_scrollDirection","_scrollOffset","getItemMetadata$1","findNearestItemBinarySearch$1","findNearestItemExponentialSearch$1","estimatedItemSize","totalSizeOfMeasuredItems","VariableSizeList","findNearestItem$1","resetAfterIndex","FixedSizeGrid","lastColumnOffset","middleOffset","ceil","_ref8","lastRowOffset","_ref9","_ref10","left","numVisibleColumns","_ref11","_ref12","numVisibleRows","_ref13","FixedSizeList","lastItemOffset","numVisibleItems","shallowDiffers","prev","next","attribute","_attribute","areEqual","prevProps","prevStyle","prevRest","nextStyle","nextRest","shouldComponentUpdate","nextState"],"mappings":"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","file":"js/core.vendors~account~trader.f4412c9c7a2377d01334.js","sourcesContent":["function areInputsEqual(newInputs, lastInputs) {\n    if (newInputs.length !== lastInputs.length) {\n        return false;\n    }\n    for (var i = 0; i < newInputs.length; i++) {\n        if (newInputs[i] !== lastInputs[i]) {\n            return false;\n        }\n    }\n    return true;\n}\n\nfunction memoizeOne(resultFn, isEqual) {\n    if (isEqual === void 0) { isEqual = areInputsEqual; }\n    var lastThis;\n    var lastArgs = [];\n    var lastResult;\n    var calledOnce = false;\n    function memoized() {\n        var newArgs = [];\n        for (var _i = 0; _i < arguments.length; _i++) {\n            newArgs[_i] = arguments[_i];\n        }\n        if (calledOnce && lastThis === this && isEqual(newArgs, lastArgs)) {\n            return lastResult;\n        }\n        lastResult = resultFn.apply(this, newArgs);\n        calledOnce = true;\n        lastThis = this;\n        lastArgs = newArgs;\n        return lastResult;\n    }\n    return memoized;\n}\n\nexport default memoizeOne;\n","import _extends from '@babel/runtime/helpers/esm/extends';\nimport _inheritsLoose from '@babel/runtime/helpers/esm/inheritsLoose';\nimport _assertThisInitialized from '@babel/runtime/helpers/esm/assertThisInitialized';\nimport memoizeOne from 'memoize-one';\nimport { createElement, PureComponent } from 'react';\nimport _objectWithoutPropertiesLoose from '@babel/runtime/helpers/esm/objectWithoutPropertiesLoose';\n\n// Animation frame based implementation of setTimeout.\n// Inspired by Joe Lambert, https://gist.github.com/joelambert/1002116#file-requesttimeout-js\nvar hasNativePerformanceNow = typeof performance === 'object' && typeof performance.now === 'function';\nvar now = hasNativePerformanceNow ? function () {\n  return performance.now();\n} : function () {\n  return Date.now();\n};\nfunction cancelTimeout(timeoutID) {\n  cancelAnimationFrame(timeoutID.id);\n}\nfunction requestTimeout(callback, delay) {\n  var start = now();\n\n  function tick() {\n    if (now() - start >= delay) {\n      callback.call(null);\n    } else {\n      timeoutID.id = requestAnimationFrame(tick);\n    }\n  }\n\n  var timeoutID = {\n    id: requestAnimationFrame(tick)\n  };\n  return timeoutID;\n}\n\nvar size = -1; // This utility copied from \"dom-helpers\" package.\n\nfunction getScrollbarSize(recalculate) {\n  if (recalculate === void 0) {\n    recalculate = false;\n  }\n\n  if (size === -1 || recalculate) {\n    var div = document.createElement('div');\n    var style = div.style;\n    style.width = '50px';\n    style.height = '50px';\n    style.overflow = 'scroll';\n    document.body.appendChild(div);\n    size = div.offsetWidth - div.clientWidth;\n    document.body.removeChild(div);\n  }\n\n  return size;\n}\nvar cachedRTLResult = null; // TRICKY According to the spec, scrollLeft should be negative for RTL aligned elements.\n// Chrome does not seem to adhere; its scrollLeft values are positive (measured relative to the left).\n// Safari's elastic bounce makes detecting this even more complicated wrt potential false positives.\n// The safest way to check this is to intentionally set a negative offset,\n// and then verify that the subsequent \"scroll\" event matches the negative offset.\n// If it does not match, then we can assume a non-standard RTL scroll implementation.\n\nfunction getRTLOffsetType(recalculate) {\n  if (recalculate === void 0) {\n    recalculate = false;\n  }\n\n  if (cachedRTLResult === null || recalculate) {\n    var outerDiv = document.createElement('div');\n    var outerStyle = outerDiv.style;\n    outerStyle.width = '50px';\n    outerStyle.height = '50px';\n    outerStyle.overflow = 'scroll';\n    outerStyle.direction = 'rtl';\n    var innerDiv = document.createElement('div');\n    var innerStyle = innerDiv.style;\n    innerStyle.width = '100px';\n    innerStyle.height = '100px';\n    outerDiv.appendChild(innerDiv);\n    document.body.appendChild(outerDiv);\n\n    if (outerDiv.scrollLeft > 0) {\n      cachedRTLResult = 'positive-descending';\n    } else {\n      outerDiv.scrollLeft = 1;\n\n      if (outerDiv.scrollLeft === 0) {\n        cachedRTLResult = 'negative';\n      } else {\n        cachedRTLResult = 'positive-ascending';\n      }\n    }\n\n    document.body.removeChild(outerDiv);\n    return cachedRTLResult;\n  }\n\n  return cachedRTLResult;\n}\n\nvar IS_SCROLLING_DEBOUNCE_INTERVAL = 150;\n\nvar defaultItemKey = function defaultItemKey(_ref) {\n  var columnIndex = _ref.columnIndex,\n      data = _ref.data,\n      rowIndex = _ref.rowIndex;\n  return rowIndex + \":\" + columnIndex;\n}; // In DEV mode, this Set helps us only log a warning once per component instance.\n// This avoids spamming the console every time a render happens.\n\n\nvar devWarningsOverscanCount = null;\nvar devWarningsOverscanRowsColumnsCount = null;\nvar devWarningsTagName = null;\n\nif (process.env.NODE_ENV !== 'production') {\n  if (typeof window !== 'undefined' && typeof window.WeakSet !== 'undefined') {\n    devWarningsOverscanCount =\n    /*#__PURE__*/\n    new WeakSet();\n    devWarningsOverscanRowsColumnsCount =\n    /*#__PURE__*/\n    new WeakSet();\n    devWarningsTagName =\n    /*#__PURE__*/\n    new WeakSet();\n  }\n}\n\nfunction createGridComponent(_ref2) {\n  var _class, _temp;\n\n  var getColumnOffset = _ref2.getColumnOffset,\n      getColumnStartIndexForOffset = _ref2.getColumnStartIndexForOffset,\n      getColumnStopIndexForStartIndex = _ref2.getColumnStopIndexForStartIndex,\n      getColumnWidth = _ref2.getColumnWidth,\n      getEstimatedTotalHeight = _ref2.getEstimatedTotalHeight,\n      getEstimatedTotalWidth = _ref2.getEstimatedTotalWidth,\n      getOffsetForColumnAndAlignment = _ref2.getOffsetForColumnAndAlignment,\n      getOffsetForRowAndAlignment = _ref2.getOffsetForRowAndAlignment,\n      getRowHeight = _ref2.getRowHeight,\n      getRowOffset = _ref2.getRowOffset,\n      getRowStartIndexForOffset = _ref2.getRowStartIndexForOffset,\n      getRowStopIndexForStartIndex = _ref2.getRowStopIndexForStartIndex,\n      initInstanceProps = _ref2.initInstanceProps,\n      shouldResetStyleCacheOnItemSizeChange = _ref2.shouldResetStyleCacheOnItemSizeChange,\n      validateProps = _ref2.validateProps;\n  return _temp = _class =\n  /*#__PURE__*/\n  function (_PureComponent) {\n    _inheritsLoose(Grid, _PureComponent);\n\n    // Always use explicit constructor for React components.\n    // It produces less code after transpilation. (#26)\n    // eslint-disable-next-line no-useless-constructor\n    function Grid(props) {\n      var _this;\n\n      _this = _PureComponent.call(this, props) || this;\n      _this._instanceProps = initInstanceProps(_this.props, _assertThisInitialized(_assertThisInitialized(_this)));\n      _this._resetIsScrollingTimeoutId = null;\n      _this._outerRef = void 0;\n      _this.state = {\n        instance: _assertThisInitialized(_assertThisInitialized(_this)),\n        isScrolling: false,\n        horizontalScrollDirection: 'forward',\n        scrollLeft: typeof _this.props.initialScrollLeft === 'number' ? _this.props.initialScrollLeft : 0,\n        scrollTop: typeof _this.props.initialScrollTop === 'number' ? _this.props.initialScrollTop : 0,\n        scrollUpdateWasRequested: false,\n        verticalScrollDirection: 'forward'\n      };\n      _this._callOnItemsRendered = void 0;\n      _this._callOnItemsRendered = memoizeOne(function (overscanColumnStartIndex, overscanColumnStopIndex, overscanRowStartIndex, overscanRowStopIndex, visibleColumnStartIndex, visibleColumnStopIndex, visibleRowStartIndex, visibleRowStopIndex) {\n        return _this.props.onItemsRendered({\n          overscanColumnStartIndex: overscanColumnStartIndex,\n          overscanColumnStopIndex: overscanColumnStopIndex,\n          overscanRowStartIndex: overscanRowStartIndex,\n          overscanRowStopIndex: overscanRowStopIndex,\n          visibleColumnStartIndex: visibleColumnStartIndex,\n          visibleColumnStopIndex: visibleColumnStopIndex,\n          visibleRowStartIndex: visibleRowStartIndex,\n          visibleRowStopIndex: visibleRowStopIndex\n        });\n      });\n      _this._callOnScroll = void 0;\n      _this._callOnScroll = memoizeOne(function (scrollLeft, scrollTop, horizontalScrollDirection, verticalScrollDirection, scrollUpdateWasRequested) {\n        return _this.props.onScroll({\n          horizontalScrollDirection: horizontalScrollDirection,\n          scrollLeft: scrollLeft,\n          scrollTop: scrollTop,\n          verticalScrollDirection: verticalScrollDirection,\n          scrollUpdateWasRequested: scrollUpdateWasRequested\n        });\n      });\n      _this._getItemStyle = void 0;\n\n      _this._getItemStyle = function (rowIndex, columnIndex) {\n        var _this$props = _this.props,\n            columnWidth = _this$props.columnWidth,\n            direction = _this$props.direction,\n            rowHeight = _this$props.rowHeight;\n\n        var itemStyleCache = _this._getItemStyleCache(shouldResetStyleCacheOnItemSizeChange && columnWidth, shouldResetStyleCacheOnItemSizeChange && direction, shouldResetStyleCacheOnItemSizeChange && rowHeight);\n\n        var key = rowIndex + \":\" + columnIndex;\n        var style;\n\n        if (itemStyleCache.hasOwnProperty(key)) {\n          style = itemStyleCache[key];\n        } else {\n          var _style;\n\n          itemStyleCache[key] = style = (_style = {\n            position: 'absolute'\n          }, _style[direction === 'rtl' ? 'right' : 'left'] = getColumnOffset(_this.props, columnIndex, _this._instanceProps), _style.top = getRowOffset(_this.props, rowIndex, _this._instanceProps), _style.height = getRowHeight(_this.props, rowIndex, _this._instanceProps), _style.width = getColumnWidth(_this.props, columnIndex, _this._instanceProps), _style);\n        }\n\n        return style;\n      };\n\n      _this._getItemStyleCache = void 0;\n      _this._getItemStyleCache = memoizeOne(function (_, __, ___) {\n        return {};\n      });\n\n      _this._onScroll = function (event) {\n        var _event$currentTarget = event.currentTarget,\n            clientHeight = _event$currentTarget.clientHeight,\n            clientWidth = _event$currentTarget.clientWidth,\n            scrollLeft = _event$currentTarget.scrollLeft,\n            scrollTop = _event$currentTarget.scrollTop,\n            scrollHeight = _event$currentTarget.scrollHeight,\n            scrollWidth = _event$currentTarget.scrollWidth;\n\n        _this.setState(function (prevState) {\n          if (prevState.scrollLeft === scrollLeft && prevState.scrollTop === scrollTop) {\n            // Scroll position may have been updated by cDM/cDU,\n            // In which case we don't need to trigger another render,\n            // And we don't want to update state.isScrolling.\n            return null;\n          }\n\n          var direction = _this.props.direction; // TRICKY According to the spec, scrollLeft should be negative for RTL aligned elements.\n          // This is not the case for all browsers though (e.g. Chrome reports values as positive, measured relative to the left).\n          // It's also easier for this component if we convert offsets to the same format as they would be in for ltr.\n          // So the simplest solution is to determine which browser behavior we're dealing with, and convert based on it.\n\n          var calculatedScrollLeft = scrollLeft;\n\n          if (direction === 'rtl') {\n            switch (getRTLOffsetType()) {\n              case 'negative':\n                calculatedScrollLeft = -scrollLeft;\n                break;\n\n              case 'positive-descending':\n                calculatedScrollLeft = scrollWidth - clientWidth - scrollLeft;\n                break;\n            }\n          } // Prevent Safari's elastic scrolling from causing visual shaking when scrolling past bounds.\n\n\n          calculatedScrollLeft = Math.max(0, Math.min(calculatedScrollLeft, scrollWidth - clientWidth));\n          var calculatedScrollTop = Math.max(0, Math.min(scrollTop, scrollHeight - clientHeight));\n          return {\n            isScrolling: true,\n            horizontalScrollDirection: prevState.scrollLeft < scrollLeft ? 'forward' : 'backward',\n            scrollLeft: calculatedScrollLeft,\n            scrollTop: calculatedScrollTop,\n            verticalScrollDirection: prevState.scrollTop < scrollTop ? 'forward' : 'backward',\n            scrollUpdateWasRequested: false\n          };\n        }, _this._resetIsScrollingDebounced);\n      };\n\n      _this._outerRefSetter = function (ref) {\n        var outerRef = _this.props.outerRef;\n        _this._outerRef = ref;\n\n        if (typeof outerRef === 'function') {\n          outerRef(ref);\n        } else if (outerRef != null && typeof outerRef === 'object' && outerRef.hasOwnProperty('current')) {\n          outerRef.current = ref;\n        }\n      };\n\n      _this._resetIsScrollingDebounced = function () {\n        if (_this._resetIsScrollingTimeoutId !== null) {\n          cancelTimeout(_this._resetIsScrollingTimeoutId);\n        }\n\n        _this._resetIsScrollingTimeoutId = requestTimeout(_this._resetIsScrolling, IS_SCROLLING_DEBOUNCE_INTERVAL);\n      };\n\n      _this._resetIsScrolling = function () {\n        _this._resetIsScrollingTimeoutId = null;\n\n        _this.setState({\n          isScrolling: false\n        }, function () {\n          // Clear style cache after state update has been committed.\n          // This way we don't break pure sCU for items that don't use isScrolling param.\n          _this._getItemStyleCache(-1);\n        });\n      };\n\n      return _this;\n    }\n\n    Grid.getDerivedStateFromProps = function getDerivedStateFromProps(nextProps, prevState) {\n      validateSharedProps(nextProps, prevState);\n      validateProps(nextProps);\n      return null;\n    };\n\n    var _proto = Grid.prototype;\n\n    _proto.scrollTo = function scrollTo(_ref3) {\n      var scrollLeft = _ref3.scrollLeft,\n          scrollTop = _ref3.scrollTop;\n\n      if (scrollLeft !== undefined) {\n        scrollLeft = Math.max(0, scrollLeft);\n      }\n\n      if (scrollTop !== undefined) {\n        scrollTop = Math.max(0, scrollTop);\n      }\n\n      this.setState(function (prevState) {\n        if (scrollLeft === undefined) {\n          scrollLeft = prevState.scrollLeft;\n        }\n\n        if (scrollTop === undefined) {\n          scrollTop = prevState.scrollTop;\n        }\n\n        if (prevState.scrollLeft === scrollLeft && prevState.scrollTop === scrollTop) {\n          return null;\n        }\n\n        return {\n          horizontalScrollDirection: prevState.scrollLeft < scrollLeft ? 'forward' : 'backward',\n          scrollLeft: scrollLeft,\n          scrollTop: scrollTop,\n          scrollUpdateWasRequested: true,\n          verticalScrollDirection: prevState.scrollTop < scrollTop ? 'forward' : 'backward'\n        };\n      }, this._resetIsScrollingDebounced);\n    };\n\n    _proto.scrollToItem = function scrollToItem(_ref4) {\n      var _ref4$align = _ref4.align,\n          align = _ref4$align === void 0 ? 'auto' : _ref4$align,\n          columnIndex = _ref4.columnIndex,\n          rowIndex = _ref4.rowIndex;\n      var _this$props2 = this.props,\n          columnCount = _this$props2.columnCount,\n          height = _this$props2.height,\n          rowCount = _this$props2.rowCount,\n          width = _this$props2.width;\n      var _this$state = this.state,\n          scrollLeft = _this$state.scrollLeft,\n          scrollTop = _this$state.scrollTop;\n      var scrollbarSize = getScrollbarSize();\n\n      if (columnIndex !== undefined) {\n        columnIndex = Math.max(0, Math.min(columnIndex, columnCount - 1));\n      }\n\n      if (rowIndex !== undefined) {\n        rowIndex = Math.max(0, Math.min(rowIndex, rowCount - 1));\n      }\n\n      var estimatedTotalHeight = getEstimatedTotalHeight(this.props, this._instanceProps);\n      var estimatedTotalWidth = getEstimatedTotalWidth(this.props, this._instanceProps); // The scrollbar size should be considered when scrolling an item into view,\n      // to ensure it's fully visible.\n      // But we only need to account for its size when it's actually visible.\n\n      var horizontalScrollbarSize = estimatedTotalWidth > width ? scrollbarSize : 0;\n      var verticalScrollbarSize = estimatedTotalHeight > height ? scrollbarSize : 0;\n      this.scrollTo({\n        scrollLeft: columnIndex !== undefined ? getOffsetForColumnAndAlignment(this.props, columnIndex, align, scrollLeft, this._instanceProps, verticalScrollbarSize) : scrollLeft,\n        scrollTop: rowIndex !== undefined ? getOffsetForRowAndAlignment(this.props, rowIndex, align, scrollTop, this._instanceProps, horizontalScrollbarSize) : scrollTop\n      });\n    };\n\n    _proto.componentDidMount = function componentDidMount() {\n      var _this$props3 = this.props,\n          initialScrollLeft = _this$props3.initialScrollLeft,\n          initialScrollTop = _this$props3.initialScrollTop;\n\n      if (this._outerRef != null) {\n        var outerRef = this._outerRef;\n\n        if (typeof initialScrollLeft === 'number') {\n          outerRef.scrollLeft = initialScrollLeft;\n        }\n\n        if (typeof initialScrollTop === 'number') {\n          outerRef.scrollTop = initialScrollTop;\n        }\n      }\n\n      this._callPropsCallbacks();\n    };\n\n    _proto.componentDidUpdate = function componentDidUpdate() {\n      var direction = this.props.direction;\n      var _this$state2 = this.state,\n          scrollLeft = _this$state2.scrollLeft,\n          scrollTop = _this$state2.scrollTop,\n          scrollUpdateWasRequested = _this$state2.scrollUpdateWasRequested;\n\n      if (scrollUpdateWasRequested && this._outerRef != null) {\n        // TRICKY According to the spec, scrollLeft should be negative for RTL aligned elements.\n        // This is not the case for all browsers though (e.g. Chrome reports values as positive, measured relative to the left).\n        // So we need to determine which browser behavior we're dealing with, and mimic it.\n        var outerRef = this._outerRef;\n\n        if (direction === 'rtl') {\n          switch (getRTLOffsetType()) {\n            case 'negative':\n              outerRef.scrollLeft = -scrollLeft;\n              break;\n\n            case 'positive-ascending':\n              outerRef.scrollLeft = scrollLeft;\n              break;\n\n            default:\n              var clientWidth = outerRef.clientWidth,\n                  scrollWidth = outerRef.scrollWidth;\n              outerRef.scrollLeft = scrollWidth - clientWidth - scrollLeft;\n              break;\n          }\n        } else {\n          outerRef.scrollLeft = Math.max(0, scrollLeft);\n        }\n\n        outerRef.scrollTop = Math.max(0, scrollTop);\n      }\n\n      this._callPropsCallbacks();\n    };\n\n    _proto.componentWillUnmount = function componentWillUnmount() {\n      if (this._resetIsScrollingTimeoutId !== null) {\n        cancelTimeout(this._resetIsScrollingTimeoutId);\n      }\n    };\n\n    _proto.render = function render() {\n      var _this$props4 = this.props,\n          children = _this$props4.children,\n          className = _this$props4.className,\n          columnCount = _this$props4.columnCount,\n          direction = _this$props4.direction,\n          height = _this$props4.height,\n          innerRef = _this$props4.innerRef,\n          innerElementType = _this$props4.innerElementType,\n          innerTagName = _this$props4.innerTagName,\n          itemData = _this$props4.itemData,\n          _this$props4$itemKey = _this$props4.itemKey,\n          itemKey = _this$props4$itemKey === void 0 ? defaultItemKey : _this$props4$itemKey,\n          outerElementType = _this$props4.outerElementType,\n          outerTagName = _this$props4.outerTagName,\n          rowCount = _this$props4.rowCount,\n          style = _this$props4.style,\n          useIsScrolling = _this$props4.useIsScrolling,\n          width = _this$props4.width;\n      var isScrolling = this.state.isScrolling;\n\n      var _this$_getHorizontalR = this._getHorizontalRangeToRender(),\n          columnStartIndex = _this$_getHorizontalR[0],\n          columnStopIndex = _this$_getHorizontalR[1];\n\n      var _this$_getVerticalRan = this._getVerticalRangeToRender(),\n          rowStartIndex = _this$_getVerticalRan[0],\n          rowStopIndex = _this$_getVerticalRan[1];\n\n      var items = [];\n\n      if (columnCount > 0 && rowCount) {\n        for (var _rowIndex = rowStartIndex; _rowIndex <= rowStopIndex; _rowIndex++) {\n          for (var _columnIndex = columnStartIndex; _columnIndex <= columnStopIndex; _columnIndex++) {\n            items.push(createElement(children, {\n              columnIndex: _columnIndex,\n              data: itemData,\n              isScrolling: useIsScrolling ? isScrolling : undefined,\n              key: itemKey({\n                columnIndex: _columnIndex,\n                data: itemData,\n                rowIndex: _rowIndex\n              }),\n              rowIndex: _rowIndex,\n              style: this._getItemStyle(_rowIndex, _columnIndex)\n            }));\n          }\n        }\n      } // Read this value AFTER items have been created,\n      // So their actual sizes (if variable) are taken into consideration.\n\n\n      var estimatedTotalHeight = getEstimatedTotalHeight(this.props, this._instanceProps);\n      var estimatedTotalWidth = getEstimatedTotalWidth(this.props, this._instanceProps);\n      return createElement(outerElementType || outerTagName || 'div', {\n        className: className,\n        onScroll: this._onScroll,\n        ref: this._outerRefSetter,\n        style: _extends({\n          position: 'relative',\n          height: height,\n          width: width,\n          overflow: 'auto',\n          WebkitOverflowScrolling: 'touch',\n          willChange: 'transform',\n          direction: direction\n        }, style)\n      }, createElement(innerElementType || innerTagName || 'div', {\n        children: items,\n        ref: innerRef,\n        style: {\n          height: estimatedTotalHeight,\n          pointerEvents: isScrolling ? 'none' : undefined,\n          width: estimatedTotalWidth\n        }\n      }));\n    };\n\n    _proto._callPropsCallbacks = function _callPropsCallbacks() {\n      var _this$props5 = this.props,\n          columnCount = _this$props5.columnCount,\n          onItemsRendered = _this$props5.onItemsRendered,\n          onScroll = _this$props5.onScroll,\n          rowCount = _this$props5.rowCount;\n\n      if (typeof onItemsRendered === 'function') {\n        if (columnCount > 0 && rowCount > 0) {\n          var _this$_getHorizontalR2 = this._getHorizontalRangeToRender(),\n              _overscanColumnStartIndex = _this$_getHorizontalR2[0],\n              _overscanColumnStopIndex = _this$_getHorizontalR2[1],\n              _visibleColumnStartIndex = _this$_getHorizontalR2[2],\n              _visibleColumnStopIndex = _this$_getHorizontalR2[3];\n\n          var _this$_getVerticalRan2 = this._getVerticalRangeToRender(),\n              _overscanRowStartIndex = _this$_getVerticalRan2[0],\n              _overscanRowStopIndex = _this$_getVerticalRan2[1],\n              _visibleRowStartIndex = _this$_getVerticalRan2[2],\n              _visibleRowStopIndex = _this$_getVerticalRan2[3];\n\n          this._callOnItemsRendered(_overscanColumnStartIndex, _overscanColumnStopIndex, _overscanRowStartIndex, _overscanRowStopIndex, _visibleColumnStartIndex, _visibleColumnStopIndex, _visibleRowStartIndex, _visibleRowStopIndex);\n        }\n      }\n\n      if (typeof onScroll === 'function') {\n        var _this$state3 = this.state,\n            _horizontalScrollDirection = _this$state3.horizontalScrollDirection,\n            _scrollLeft = _this$state3.scrollLeft,\n            _scrollTop = _this$state3.scrollTop,\n            _scrollUpdateWasRequested = _this$state3.scrollUpdateWasRequested,\n            _verticalScrollDirection = _this$state3.verticalScrollDirection;\n\n        this._callOnScroll(_scrollLeft, _scrollTop, _horizontalScrollDirection, _verticalScrollDirection, _scrollUpdateWasRequested);\n      }\n    }; // Lazily create and cache item styles while scrolling,\n    // So that pure component sCU will prevent re-renders.\n    // We maintain this cache, and pass a style prop rather than index,\n    // So that List can clear cached styles and force item re-render if necessary.\n\n\n    _proto._getHorizontalRangeToRender = function _getHorizontalRangeToRender() {\n      var _this$props6 = this.props,\n          columnCount = _this$props6.columnCount,\n          overscanColumnCount = _this$props6.overscanColumnCount,\n          overscanColumnsCount = _this$props6.overscanColumnsCount,\n          overscanCount = _this$props6.overscanCount,\n          rowCount = _this$props6.rowCount;\n      var _this$state4 = this.state,\n          horizontalScrollDirection = _this$state4.horizontalScrollDirection,\n          isScrolling = _this$state4.isScrolling,\n          scrollLeft = _this$state4.scrollLeft;\n      var overscanCountResolved = overscanColumnCount || overscanColumnsCount || overscanCount || 1;\n\n      if (columnCount === 0 || rowCount === 0) {\n        return [0, 0, 0, 0];\n      }\n\n      var startIndex = getColumnStartIndexForOffset(this.props, scrollLeft, this._instanceProps);\n      var stopIndex = getColumnStopIndexForStartIndex(this.props, startIndex, scrollLeft, this._instanceProps); // Overscan by one item in each direction so that tab/focus works.\n      // If there isn't at least one extra item, tab loops back around.\n\n      var overscanBackward = !isScrolling || horizontalScrollDirection === 'backward' ? Math.max(1, overscanCountResolved) : 1;\n      var overscanForward = !isScrolling || horizontalScrollDirection === 'forward' ? Math.max(1, overscanCountResolved) : 1;\n      return [Math.max(0, startIndex - overscanBackward), Math.max(0, Math.min(columnCount - 1, stopIndex + overscanForward)), startIndex, stopIndex];\n    };\n\n    _proto._getVerticalRangeToRender = function _getVerticalRangeToRender() {\n      var _this$props7 = this.props,\n          columnCount = _this$props7.columnCount,\n          overscanCount = _this$props7.overscanCount,\n          overscanRowCount = _this$props7.overscanRowCount,\n          overscanRowsCount = _this$props7.overscanRowsCount,\n          rowCount = _this$props7.rowCount;\n      var _this$state5 = this.state,\n          isScrolling = _this$state5.isScrolling,\n          verticalScrollDirection = _this$state5.verticalScrollDirection,\n          scrollTop = _this$state5.scrollTop;\n      var overscanCountResolved = overscanRowCount || overscanRowsCount || overscanCount || 1;\n\n      if (columnCount === 0 || rowCount === 0) {\n        return [0, 0, 0, 0];\n      }\n\n      var startIndex = getRowStartIndexForOffset(this.props, scrollTop, this._instanceProps);\n      var stopIndex = getRowStopIndexForStartIndex(this.props, startIndex, scrollTop, this._instanceProps); // Overscan by one item in each direction so that tab/focus works.\n      // If there isn't at least one extra item, tab loops back around.\n\n      var overscanBackward = !isScrolling || verticalScrollDirection === 'backward' ? Math.max(1, overscanCountResolved) : 1;\n      var overscanForward = !isScrolling || verticalScrollDirection === 'forward' ? Math.max(1, overscanCountResolved) : 1;\n      return [Math.max(0, startIndex - overscanBackward), Math.max(0, Math.min(rowCount - 1, stopIndex + overscanForward)), startIndex, stopIndex];\n    };\n\n    return Grid;\n  }(PureComponent), _class.defaultProps = {\n    direction: 'ltr',\n    itemData: undefined,\n    useIsScrolling: false\n  }, _temp;\n}\n\nvar validateSharedProps = function validateSharedProps(_ref5, _ref6) {\n  var children = _ref5.children,\n      direction = _ref5.direction,\n      height = _ref5.height,\n      innerTagName = _ref5.innerTagName,\n      outerTagName = _ref5.outerTagName,\n      overscanColumnsCount = _ref5.overscanColumnsCount,\n      overscanCount = _ref5.overscanCount,\n      overscanRowsCount = _ref5.overscanRowsCount,\n      width = _ref5.width;\n  var instance = _ref6.instance;\n\n  if (process.env.NODE_ENV !== 'production') {\n    if (typeof overscanCount === 'number') {\n      if (devWarningsOverscanCount && !devWarningsOverscanCount.has(instance)) {\n        devWarningsOverscanCount.add(instance);\n        console.warn('The overscanCount prop has been deprecated. ' + 'Please use the overscanColumnCount and overscanRowCount props instead.');\n      }\n    }\n\n    if (typeof overscanColumnsCount === 'number' || typeof overscanRowsCount === 'number') {\n      if (devWarningsOverscanRowsColumnsCount && !devWarningsOverscanRowsColumnsCount.has(instance)) {\n        devWarningsOverscanRowsColumnsCount.add(instance);\n        console.warn('The overscanColumnsCount and overscanRowsCount props have been deprecated. ' + 'Please use the overscanColumnCount and overscanRowCount props instead.');\n      }\n    }\n\n    if (innerTagName != null || outerTagName != null) {\n      if (devWarningsTagName && !devWarningsTagName.has(instance)) {\n        devWarningsTagName.add(instance);\n        console.warn('The innerTagName and outerTagName props have been deprecated. ' + 'Please use the innerElementType and outerElementType props instead.');\n      }\n    }\n\n    if (children == null) {\n      throw Error('An invalid \"children\" prop has been specified. ' + 'Value should be a React component. ' + (\"\\\"\" + (children === null ? 'null' : typeof children) + \"\\\" was specified.\"));\n    }\n\n    switch (direction) {\n      case 'ltr':\n      case 'rtl':\n        // Valid values\n        break;\n\n      default:\n        throw Error('An invalid \"direction\" prop has been specified. ' + 'Value should be either \"ltr\" or \"rtl\". ' + (\"\\\"\" + direction + \"\\\" was specified.\"));\n    }\n\n    if (typeof width !== 'number') {\n      throw Error('An invalid \"width\" prop has been specified. ' + 'Grids must specify a number for width. ' + (\"\\\"\" + (width === null ? 'null' : typeof width) + \"\\\" was specified.\"));\n    }\n\n    if (typeof height !== 'number') {\n      throw Error('An invalid \"height\" prop has been specified. ' + 'Grids must specify a number for height. ' + (\"\\\"\" + (height === null ? 'null' : typeof height) + \"\\\" was specified.\"));\n    }\n  }\n};\n\nvar DEFAULT_ESTIMATED_ITEM_SIZE = 50;\n\nvar getEstimatedTotalHeight = function getEstimatedTotalHeight(_ref, _ref2) {\n  var rowCount = _ref.rowCount;\n  var rowMetadataMap = _ref2.rowMetadataMap,\n      estimatedRowHeight = _ref2.estimatedRowHeight,\n      lastMeasuredRowIndex = _ref2.lastMeasuredRowIndex;\n  var totalSizeOfMeasuredRows = 0; // Edge case check for when the number of items decreases while a scroll is in progress.\n  // https://github.com/bvaughn/react-window/pull/138\n\n  if (lastMeasuredRowIndex >= rowCount) {\n    lastMeasuredRowIndex = rowCount - 1;\n  }\n\n  if (lastMeasuredRowIndex >= 0) {\n    var itemMetadata = rowMetadataMap[lastMeasuredRowIndex];\n    totalSizeOfMeasuredRows = itemMetadata.offset + itemMetadata.size;\n  }\n\n  var numUnmeasuredItems = rowCount - lastMeasuredRowIndex - 1;\n  var totalSizeOfUnmeasuredItems = numUnmeasuredItems * estimatedRowHeight;\n  return totalSizeOfMeasuredRows + totalSizeOfUnmeasuredItems;\n};\n\nvar getEstimatedTotalWidth = function getEstimatedTotalWidth(_ref3, _ref4) {\n  var columnCount = _ref3.columnCount;\n  var columnMetadataMap = _ref4.columnMetadataMap,\n      estimatedColumnWidth = _ref4.estimatedColumnWidth,\n      lastMeasuredColumnIndex = _ref4.lastMeasuredColumnIndex;\n  var totalSizeOfMeasuredRows = 0; // Edge case check for when the number of items decreases while a scroll is in progress.\n  // https://github.com/bvaughn/react-window/pull/138\n\n  if (lastMeasuredColumnIndex >= columnCount) {\n    lastMeasuredColumnIndex = columnCount - 1;\n  }\n\n  if (lastMeasuredColumnIndex >= 0) {\n    var itemMetadata = columnMetadataMap[lastMeasuredColumnIndex];\n    totalSizeOfMeasuredRows = itemMetadata.offset + itemMetadata.size;\n  }\n\n  var numUnmeasuredItems = columnCount - lastMeasuredColumnIndex - 1;\n  var totalSizeOfUnmeasuredItems = numUnmeasuredItems * estimatedColumnWidth;\n  return totalSizeOfMeasuredRows + totalSizeOfUnmeasuredItems;\n};\n\nvar getItemMetadata = function getItemMetadata(itemType, props, index, instanceProps) {\n  var itemMetadataMap, itemSize, lastMeasuredIndex;\n\n  if (itemType === 'column') {\n    itemMetadataMap = instanceProps.columnMetadataMap;\n    itemSize = props.columnWidth;\n    lastMeasuredIndex = instanceProps.lastMeasuredColumnIndex;\n  } else {\n    itemMetadataMap = instanceProps.rowMetadataMap;\n    itemSize = props.rowHeight;\n    lastMeasuredIndex = instanceProps.lastMeasuredRowIndex;\n  }\n\n  if (index > lastMeasuredIndex) {\n    var offset = 0;\n\n    if (lastMeasuredIndex >= 0) {\n      var itemMetadata = itemMetadataMap[lastMeasuredIndex];\n      offset = itemMetadata.offset + itemMetadata.size;\n    }\n\n    for (var i = lastMeasuredIndex + 1; i <= index; i++) {\n      var size = itemSize(i);\n      itemMetadataMap[i] = {\n        offset: offset,\n        size: size\n      };\n      offset += size;\n    }\n\n    if (itemType === 'column') {\n      instanceProps.lastMeasuredColumnIndex = index;\n    } else {\n      instanceProps.lastMeasuredRowIndex = index;\n    }\n  }\n\n  return itemMetadataMap[index];\n};\n\nvar findNearestItem = function findNearestItem(itemType, props, instanceProps, offset) {\n  var itemMetadataMap, lastMeasuredIndex;\n\n  if (itemType === 'column') {\n    itemMetadataMap = instanceProps.columnMetadataMap;\n    lastMeasuredIndex = instanceProps.lastMeasuredColumnIndex;\n  } else {\n    itemMetadataMap = instanceProps.rowMetadataMap;\n    lastMeasuredIndex = instanceProps.lastMeasuredRowIndex;\n  }\n\n  var lastMeasuredItemOffset = lastMeasuredIndex > 0 ? itemMetadataMap[lastMeasuredIndex].offset : 0;\n\n  if (lastMeasuredItemOffset >= offset) {\n    // If we've already measured items within this range just use a binary search as it's faster.\n    return findNearestItemBinarySearch(itemType, props, instanceProps, lastMeasuredIndex, 0, offset);\n  } else {\n    // If we haven't yet measured this high, fallback to an exponential search with an inner binary search.\n    // The exponential search avoids pre-computing sizes for the full set of items as a binary search would.\n    // The overall complexity for this approach is O(log n).\n    return findNearestItemExponentialSearch(itemType, props, instanceProps, Math.max(0, lastMeasuredIndex), offset);\n  }\n};\n\nvar findNearestItemBinarySearch = function findNearestItemBinarySearch(itemType, props, instanceProps, high, low, offset) {\n  while (low <= high) {\n    var middle = low + Math.floor((high - low) / 2);\n    var currentOffset = getItemMetadata(itemType, props, middle, instanceProps).offset;\n\n    if (currentOffset === offset) {\n      return middle;\n    } else if (currentOffset < offset) {\n      low = middle + 1;\n    } else if (currentOffset > offset) {\n      high = middle - 1;\n    }\n  }\n\n  if (low > 0) {\n    return low - 1;\n  } else {\n    return 0;\n  }\n};\n\nvar findNearestItemExponentialSearch = function findNearestItemExponentialSearch(itemType, props, instanceProps, index, offset) {\n  var itemCount = itemType === 'column' ? props.columnCount : props.rowCount;\n  var interval = 1;\n\n  while (index < itemCount && getItemMetadata(itemType, props, index, instanceProps).offset < offset) {\n    index += interval;\n    interval *= 2;\n  }\n\n  return findNearestItemBinarySearch(itemType, props, instanceProps, Math.min(index, itemCount - 1), Math.floor(index / 2), offset);\n};\n\nvar getOffsetForIndexAndAlignment = function getOffsetForIndexAndAlignment(itemType, props, index, align, scrollOffset, instanceProps, scrollbarSize) {\n  var size = itemType === 'column' ? props.width : props.height;\n  var itemMetadata = getItemMetadata(itemType, props, index, instanceProps); // Get estimated total size after ItemMetadata is computed,\n  // To ensure it reflects actual measurements instead of just estimates.\n\n  var estimatedTotalSize = itemType === 'column' ? getEstimatedTotalWidth(props, instanceProps) : getEstimatedTotalHeight(props, instanceProps);\n  var maxOffset = Math.max(0, Math.min(estimatedTotalSize - size, itemMetadata.offset));\n  var minOffset = Math.max(0, itemMetadata.offset - size + scrollbarSize + itemMetadata.size);\n\n  if (align === 'smart') {\n    if (scrollOffset >= minOffset - size && scrollOffset <= maxOffset + size) {\n      align = 'auto';\n    } else {\n      align = 'center';\n    }\n  }\n\n  switch (align) {\n    case 'start':\n      return maxOffset;\n\n    case 'end':\n      return minOffset;\n\n    case 'center':\n      return Math.round(minOffset + (maxOffset - minOffset) / 2);\n\n    case 'auto':\n    default:\n      if (scrollOffset >= minOffset && scrollOffset <= maxOffset) {\n        return scrollOffset;\n      } else if (minOffset > maxOffset) {\n        // Because we only take into account the scrollbar size when calculating minOffset\n        // this value can be larger than maxOffset when at the end of the list\n        return minOffset;\n      } else if (scrollOffset < minOffset) {\n        return minOffset;\n      } else {\n        return maxOffset;\n      }\n\n  }\n};\n\nvar VariableSizeGrid =\n/*#__PURE__*/\ncreateGridComponent({\n  getColumnOffset: function getColumnOffset(props, index, instanceProps) {\n    return getItemMetadata('column', props, index, instanceProps).offset;\n  },\n  getColumnStartIndexForOffset: function getColumnStartIndexForOffset(props, scrollLeft, instanceProps) {\n    return findNearestItem('column', props, instanceProps, scrollLeft);\n  },\n  getColumnStopIndexForStartIndex: function getColumnStopIndexForStartIndex(props, startIndex, scrollLeft, instanceProps) {\n    var columnCount = props.columnCount,\n        width = props.width;\n    var itemMetadata = getItemMetadata('column', props, startIndex, instanceProps);\n    var maxOffset = scrollLeft + width;\n    var offset = itemMetadata.offset + itemMetadata.size;\n    var stopIndex = startIndex;\n\n    while (stopIndex < columnCount - 1 && offset < maxOffset) {\n      stopIndex++;\n      offset += getItemMetadata('column', props, stopIndex, instanceProps).size;\n    }\n\n    return stopIndex;\n  },\n  getColumnWidth: function getColumnWidth(props, index, instanceProps) {\n    return instanceProps.columnMetadataMap[index].size;\n  },\n  getEstimatedTotalHeight: getEstimatedTotalHeight,\n  getEstimatedTotalWidth: getEstimatedTotalWidth,\n  getOffsetForColumnAndAlignment: function getOffsetForColumnAndAlignment(props, index, align, scrollOffset, instanceProps, scrollbarSize) {\n    return getOffsetForIndexAndAlignment('column', props, index, align, scrollOffset, instanceProps, scrollbarSize);\n  },\n  getOffsetForRowAndAlignment: function getOffsetForRowAndAlignment(props, index, align, scrollOffset, instanceProps, scrollbarSize) {\n    return getOffsetForIndexAndAlignment('row', props, index, align, scrollOffset, instanceProps, scrollbarSize);\n  },\n  getRowOffset: function getRowOffset(props, index, instanceProps) {\n    return getItemMetadata('row', props, index, instanceProps).offset;\n  },\n  getRowHeight: function getRowHeight(props, index, instanceProps) {\n    return instanceProps.rowMetadataMap[index].size;\n  },\n  getRowStartIndexForOffset: function getRowStartIndexForOffset(props, scrollTop, instanceProps) {\n    return findNearestItem('row', props, instanceProps, scrollTop);\n  },\n  getRowStopIndexForStartIndex: function getRowStopIndexForStartIndex(props, startIndex, scrollTop, instanceProps) {\n    var rowCount = props.rowCount,\n        height = props.height;\n    var itemMetadata = getItemMetadata('row', props, startIndex, instanceProps);\n    var maxOffset = scrollTop + height;\n    var offset = itemMetadata.offset + itemMetadata.size;\n    var stopIndex = startIndex;\n\n    while (stopIndex < rowCount - 1 && offset < maxOffset) {\n      stopIndex++;\n      offset += getItemMetadata('row', props, stopIndex, instanceProps).size;\n    }\n\n    return stopIndex;\n  },\n  initInstanceProps: function initInstanceProps(props, instance) {\n    var _ref5 = props,\n        estimatedColumnWidth = _ref5.estimatedColumnWidth,\n        estimatedRowHeight = _ref5.estimatedRowHeight;\n    var instanceProps = {\n      columnMetadataMap: {},\n      estimatedColumnWidth: estimatedColumnWidth || DEFAULT_ESTIMATED_ITEM_SIZE,\n      estimatedRowHeight: estimatedRowHeight || DEFAULT_ESTIMATED_ITEM_SIZE,\n      lastMeasuredColumnIndex: -1,\n      lastMeasuredRowIndex: -1,\n      rowMetadataMap: {}\n    };\n\n    instance.resetAfterColumnIndex = function (columnIndex, shouldForceUpdate) {\n      if (shouldForceUpdate === void 0) {\n        shouldForceUpdate = true;\n      }\n\n      instance.resetAfterIndices({\n        columnIndex: columnIndex,\n        shouldForceUpdate: shouldForceUpdate\n      });\n    };\n\n    instance.resetAfterRowIndex = function (rowIndex, shouldForceUpdate) {\n      if (shouldForceUpdate === void 0) {\n        shouldForceUpdate = true;\n      }\n\n      instance.resetAfterIndices({\n        rowIndex: rowIndex,\n        shouldForceUpdate: shouldForceUpdate\n      });\n    };\n\n    instance.resetAfterIndices = function (_ref6) {\n      var columnIndex = _ref6.columnIndex,\n          rowIndex = _ref6.rowIndex,\n          _ref6$shouldForceUpda = _ref6.shouldForceUpdate,\n          shouldForceUpdate = _ref6$shouldForceUpda === void 0 ? true : _ref6$shouldForceUpda;\n\n      if (typeof columnIndex === 'number') {\n        instanceProps.lastMeasuredColumnIndex = Math.min(instanceProps.lastMeasuredColumnIndex, columnIndex - 1);\n      }\n\n      if (typeof rowIndex === 'number') {\n        instanceProps.lastMeasuredRowIndex = Math.min(instanceProps.lastMeasuredRowIndex, rowIndex - 1);\n      } // We could potentially optimize further by only evicting styles after this index,\n      // But since styles are only cached while scrolling is in progress-\n      // It seems an unnecessary optimization.\n      // It's unlikely that resetAfterIndex() will be called while a user is scrolling.\n\n\n      instance._getItemStyleCache(-1);\n\n      if (shouldForceUpdate) {\n        instance.forceUpdate();\n      }\n    };\n\n    return instanceProps;\n  },\n  shouldResetStyleCacheOnItemSizeChange: false,\n  validateProps: function validateProps(_ref7) {\n    var columnWidth = _ref7.columnWidth,\n        rowHeight = _ref7.rowHeight;\n\n    if (process.env.NODE_ENV !== 'production') {\n      if (typeof columnWidth !== 'function') {\n        throw Error('An invalid \"columnWidth\" prop has been specified. ' + 'Value should be a function. ' + (\"\\\"\" + (columnWidth === null ? 'null' : typeof columnWidth) + \"\\\" was specified.\"));\n      } else if (typeof rowHeight !== 'function') {\n        throw Error('An invalid \"rowHeight\" prop has been specified. ' + 'Value should be a function. ' + (\"\\\"\" + (rowHeight === null ? 'null' : typeof rowHeight) + \"\\\" was specified.\"));\n      }\n    }\n  }\n});\n\nvar IS_SCROLLING_DEBOUNCE_INTERVAL$1 = 150;\n\nvar defaultItemKey$1 = function defaultItemKey(index, data) {\n  return index;\n}; // In DEV mode, this Set helps us only log a warning once per component instance.\n// This avoids spamming the console every time a render happens.\n\n\nvar devWarningsDirection = null;\nvar devWarningsTagName$1 = null;\n\nif (process.env.NODE_ENV !== 'production') {\n  if (typeof window !== 'undefined' && typeof window.WeakSet !== 'undefined') {\n    devWarningsDirection =\n    /*#__PURE__*/\n    new WeakSet();\n    devWarningsTagName$1 =\n    /*#__PURE__*/\n    new WeakSet();\n  }\n}\n\nfunction createListComponent(_ref) {\n  var _class, _temp;\n\n  var getItemOffset = _ref.getItemOffset,\n      getEstimatedTotalSize = _ref.getEstimatedTotalSize,\n      getItemSize = _ref.getItemSize,\n      getOffsetForIndexAndAlignment = _ref.getOffsetForIndexAndAlignment,\n      getStartIndexForOffset = _ref.getStartIndexForOffset,\n      getStopIndexForStartIndex = _ref.getStopIndexForStartIndex,\n      initInstanceProps = _ref.initInstanceProps,\n      shouldResetStyleCacheOnItemSizeChange = _ref.shouldResetStyleCacheOnItemSizeChange,\n      validateProps = _ref.validateProps;\n  return _temp = _class =\n  /*#__PURE__*/\n  function (_PureComponent) {\n    _inheritsLoose(List, _PureComponent);\n\n    // Always use explicit constructor for React components.\n    // It produces less code after transpilation. (#26)\n    // eslint-disable-next-line no-useless-constructor\n    function List(props) {\n      var _this;\n\n      _this = _PureComponent.call(this, props) || this;\n      _this._instanceProps = initInstanceProps(_this.props, _assertThisInitialized(_assertThisInitialized(_this)));\n      _this._outerRef = void 0;\n      _this._resetIsScrollingTimeoutId = null;\n      _this.state = {\n        instance: _assertThisInitialized(_assertThisInitialized(_this)),\n        isScrolling: false,\n        scrollDirection: 'forward',\n        scrollOffset: typeof _this.props.initialScrollOffset === 'number' ? _this.props.initialScrollOffset : 0,\n        scrollUpdateWasRequested: false\n      };\n      _this._callOnItemsRendered = void 0;\n      _this._callOnItemsRendered = memoizeOne(function (overscanStartIndex, overscanStopIndex, visibleStartIndex, visibleStopIndex) {\n        return _this.props.onItemsRendered({\n          overscanStartIndex: overscanStartIndex,\n          overscanStopIndex: overscanStopIndex,\n          visibleStartIndex: visibleStartIndex,\n          visibleStopIndex: visibleStopIndex\n        });\n      });\n      _this._callOnScroll = void 0;\n      _this._callOnScroll = memoizeOne(function (scrollDirection, scrollOffset, scrollUpdateWasRequested) {\n        return _this.props.onScroll({\n          scrollDirection: scrollDirection,\n          scrollOffset: scrollOffset,\n          scrollUpdateWasRequested: scrollUpdateWasRequested\n        });\n      });\n      _this._getItemStyle = void 0;\n\n      _this._getItemStyle = function (index) {\n        var _this$props = _this.props,\n            direction = _this$props.direction,\n            itemSize = _this$props.itemSize,\n            layout = _this$props.layout;\n\n        var itemStyleCache = _this._getItemStyleCache(shouldResetStyleCacheOnItemSizeChange && itemSize, shouldResetStyleCacheOnItemSizeChange && layout, shouldResetStyleCacheOnItemSizeChange && direction);\n\n        var style;\n\n        if (itemStyleCache.hasOwnProperty(index)) {\n          style = itemStyleCache[index];\n        } else {\n          var _style;\n\n          var _offset = getItemOffset(_this.props, index, _this._instanceProps);\n\n          var size = getItemSize(_this.props, index, _this._instanceProps); // TODO Deprecate direction \"horizontal\"\n\n          var isHorizontal = direction === 'horizontal' || layout === 'horizontal';\n          itemStyleCache[index] = style = (_style = {\n            position: 'absolute'\n          }, _style[direction === 'rtl' ? 'right' : 'left'] = isHorizontal ? _offset : 0, _style.top = !isHorizontal ? _offset : 0, _style.height = !isHorizontal ? size : '100%', _style.width = isHorizontal ? size : '100%', _style);\n        }\n\n        return style;\n      };\n\n      _this._getItemStyleCache = void 0;\n      _this._getItemStyleCache = memoizeOne(function (_, __, ___) {\n        return {};\n      });\n\n      _this._onScrollHorizontal = function (event) {\n        var _event$currentTarget = event.currentTarget,\n            clientWidth = _event$currentTarget.clientWidth,\n            scrollLeft = _event$currentTarget.scrollLeft,\n            scrollWidth = _event$currentTarget.scrollWidth;\n\n        _this.setState(function (prevState) {\n          if (prevState.scrollOffset === scrollLeft) {\n            // Scroll position may have been updated by cDM/cDU,\n            // In which case we don't need to trigger another render,\n            // And we don't want to update state.isScrolling.\n            return null;\n          }\n\n          var direction = _this.props.direction;\n          var scrollOffset = scrollLeft;\n\n          if (direction === 'rtl') {\n            // TRICKY According to the spec, scrollLeft should be negative for RTL aligned elements.\n            // This is not the case for all browsers though (e.g. Chrome reports values as positive, measured relative to the left).\n            // It's also easier for this component if we convert offsets to the same format as they would be in for ltr.\n            // So the simplest solution is to determine which browser behavior we're dealing with, and convert based on it.\n            switch (getRTLOffsetType()) {\n              case 'negative':\n                scrollOffset = -scrollLeft;\n                break;\n\n              case 'positive-descending':\n                scrollOffset = scrollWidth - clientWidth - scrollLeft;\n                break;\n            }\n          } // Prevent Safari's elastic scrolling from causing visual shaking when scrolling past bounds.\n\n\n          scrollOffset = Math.max(0, Math.min(scrollOffset, scrollWidth - clientWidth));\n          return {\n            isScrolling: true,\n            scrollDirection: prevState.scrollOffset < scrollLeft ? 'forward' : 'backward',\n            scrollOffset: scrollOffset,\n            scrollUpdateWasRequested: false\n          };\n        }, _this._resetIsScrollingDebounced);\n      };\n\n      _this._onScrollVertical = function (event) {\n        var _event$currentTarget2 = event.currentTarget,\n            clientHeight = _event$currentTarget2.clientHeight,\n            scrollHeight = _event$currentTarget2.scrollHeight,\n            scrollTop = _event$currentTarget2.scrollTop;\n\n        _this.setState(function (prevState) {\n          if (prevState.scrollOffset === scrollTop) {\n            // Scroll position may have been updated by cDM/cDU,\n            // In which case we don't need to trigger another render,\n            // And we don't want to update state.isScrolling.\n            return null;\n          } // Prevent Safari's elastic scrolling from causing visual shaking when scrolling past bounds.\n\n\n          var scrollOffset = Math.max(0, Math.min(scrollTop, scrollHeight - clientHeight));\n          return {\n            isScrolling: true,\n            scrollDirection: prevState.scrollOffset < scrollOffset ? 'forward' : 'backward',\n            scrollOffset: scrollOffset,\n            scrollUpdateWasRequested: false\n          };\n        }, _this._resetIsScrollingDebounced);\n      };\n\n      _this._outerRefSetter = function (ref) {\n        var outerRef = _this.props.outerRef;\n        _this._outerRef = ref;\n\n        if (typeof outerRef === 'function') {\n          outerRef(ref);\n        } else if (outerRef != null && typeof outerRef === 'object' && outerRef.hasOwnProperty('current')) {\n          outerRef.current = ref;\n        }\n      };\n\n      _this._resetIsScrollingDebounced = function () {\n        if (_this._resetIsScrollingTimeoutId !== null) {\n          cancelTimeout(_this._resetIsScrollingTimeoutId);\n        }\n\n        _this._resetIsScrollingTimeoutId = requestTimeout(_this._resetIsScrolling, IS_SCROLLING_DEBOUNCE_INTERVAL$1);\n      };\n\n      _this._resetIsScrolling = function () {\n        _this._resetIsScrollingTimeoutId = null;\n\n        _this.setState({\n          isScrolling: false\n        }, function () {\n          // Clear style cache after state update has been committed.\n          // This way we don't break pure sCU for items that don't use isScrolling param.\n          _this._getItemStyleCache(-1, null);\n        });\n      };\n\n      return _this;\n    }\n\n    List.getDerivedStateFromProps = function getDerivedStateFromProps(nextProps, prevState) {\n      validateSharedProps$1(nextProps, prevState);\n      validateProps(nextProps);\n      return null;\n    };\n\n    var _proto = List.prototype;\n\n    _proto.scrollTo = function scrollTo(scrollOffset) {\n      scrollOffset = Math.max(0, scrollOffset);\n      this.setState(function (prevState) {\n        if (prevState.scrollOffset === scrollOffset) {\n          return null;\n        }\n\n        return {\n          scrollDirection: prevState.scrollOffset < scrollOffset ? 'forward' : 'backward',\n          scrollOffset: scrollOffset,\n          scrollUpdateWasRequested: true\n        };\n      }, this._resetIsScrollingDebounced);\n    };\n\n    _proto.scrollToItem = function scrollToItem(index, align) {\n      if (align === void 0) {\n        align = 'auto';\n      }\n\n      var itemCount = this.props.itemCount;\n      var scrollOffset = this.state.scrollOffset;\n      index = Math.max(0, Math.min(index, itemCount - 1));\n      this.scrollTo(getOffsetForIndexAndAlignment(this.props, index, align, scrollOffset, this._instanceProps));\n    };\n\n    _proto.componentDidMount = function componentDidMount() {\n      var _this$props2 = this.props,\n          direction = _this$props2.direction,\n          initialScrollOffset = _this$props2.initialScrollOffset,\n          layout = _this$props2.layout;\n\n      if (typeof initialScrollOffset === 'number' && this._outerRef != null) {\n        var outerRef = this._outerRef; // TODO Deprecate direction \"horizontal\"\n\n        if (direction === 'horizontal' || layout === 'horizontal') {\n          outerRef.scrollLeft = initialScrollOffset;\n        } else {\n          outerRef.scrollTop = initialScrollOffset;\n        }\n      }\n\n      this._callPropsCallbacks();\n    };\n\n    _proto.componentDidUpdate = function componentDidUpdate() {\n      var _this$props3 = this.props,\n          direction = _this$props3.direction,\n          layout = _this$props3.layout;\n      var _this$state = this.state,\n          scrollOffset = _this$state.scrollOffset,\n          scrollUpdateWasRequested = _this$state.scrollUpdateWasRequested;\n\n      if (scrollUpdateWasRequested && this._outerRef != null) {\n        var outerRef = this._outerRef; // TODO Deprecate direction \"horizontal\"\n\n        if (direction === 'horizontal' || layout === 'horizontal') {\n          if (direction === 'rtl') {\n            // TRICKY According to the spec, scrollLeft should be negative for RTL aligned elements.\n            // This is not the case for all browsers though (e.g. Chrome reports values as positive, measured relative to the left).\n            // So we need to determine which browser behavior we're dealing with, and mimic it.\n            switch (getRTLOffsetType()) {\n              case 'negative':\n                outerRef.scrollLeft = -scrollOffset;\n                break;\n\n              case 'positive-ascending':\n                outerRef.scrollLeft = scrollOffset;\n                break;\n\n              default:\n                var clientWidth = outerRef.clientWidth,\n                    scrollWidth = outerRef.scrollWidth;\n                outerRef.scrollLeft = scrollWidth - clientWidth - scrollOffset;\n                break;\n            }\n          } else {\n            outerRef.scrollLeft = scrollOffset;\n          }\n        } else {\n          outerRef.scrollTop = scrollOffset;\n        }\n      }\n\n      this._callPropsCallbacks();\n    };\n\n    _proto.componentWillUnmount = function componentWillUnmount() {\n      if (this._resetIsScrollingTimeoutId !== null) {\n        cancelTimeout(this._resetIsScrollingTimeoutId);\n      }\n    };\n\n    _proto.render = function render() {\n      var _this$props4 = this.props,\n          children = _this$props4.children,\n          className = _this$props4.className,\n          direction = _this$props4.direction,\n          height = _this$props4.height,\n          innerRef = _this$props4.innerRef,\n          innerElementType = _this$props4.innerElementType,\n          innerTagName = _this$props4.innerTagName,\n          itemCount = _this$props4.itemCount,\n          itemData = _this$props4.itemData,\n          _this$props4$itemKey = _this$props4.itemKey,\n          itemKey = _this$props4$itemKey === void 0 ? defaultItemKey$1 : _this$props4$itemKey,\n          layout = _this$props4.layout,\n          outerElementType = _this$props4.outerElementType,\n          outerTagName = _this$props4.outerTagName,\n          style = _this$props4.style,\n          useIsScrolling = _this$props4.useIsScrolling,\n          width = _this$props4.width;\n      var isScrolling = this.state.isScrolling; // TODO Deprecate direction \"horizontal\"\n\n      var isHorizontal = direction === 'horizontal' || layout === 'horizontal';\n      var onScroll = isHorizontal ? this._onScrollHorizontal : this._onScrollVertical;\n\n      var _this$_getRangeToRend = this._getRangeToRender(),\n          startIndex = _this$_getRangeToRend[0],\n          stopIndex = _this$_getRangeToRend[1];\n\n      var items = [];\n\n      if (itemCount > 0) {\n        for (var _index = startIndex; _index <= stopIndex; _index++) {\n          items.push(createElement(children, {\n            data: itemData,\n            key: itemKey(_index, itemData),\n            index: _index,\n            isScrolling: useIsScrolling ? isScrolling : undefined,\n            style: this._getItemStyle(_index)\n          }));\n        }\n      } // Read this value AFTER items have been created,\n      // So their actual sizes (if variable) are taken into consideration.\n\n\n      var estimatedTotalSize = getEstimatedTotalSize(this.props, this._instanceProps);\n      return createElement(outerElementType || outerTagName || 'div', {\n        className: className,\n        onScroll: onScroll,\n        ref: this._outerRefSetter,\n        style: _extends({\n          position: 'relative',\n          height: height,\n          width: width,\n          overflow: 'auto',\n          WebkitOverflowScrolling: 'touch',\n          willChange: 'transform',\n          direction: direction\n        }, style)\n      }, createElement(innerElementType || innerTagName || 'div', {\n        children: items,\n        ref: innerRef,\n        style: {\n          height: isHorizontal ? '100%' : estimatedTotalSize,\n          pointerEvents: isScrolling ? 'none' : undefined,\n          width: isHorizontal ? estimatedTotalSize : '100%'\n        }\n      }));\n    };\n\n    _proto._callPropsCallbacks = function _callPropsCallbacks() {\n      if (typeof this.props.onItemsRendered === 'function') {\n        var itemCount = this.props.itemCount;\n\n        if (itemCount > 0) {\n          var _this$_getRangeToRend2 = this._getRangeToRender(),\n              _overscanStartIndex = _this$_getRangeToRend2[0],\n              _overscanStopIndex = _this$_getRangeToRend2[1],\n              _visibleStartIndex = _this$_getRangeToRend2[2],\n              _visibleStopIndex = _this$_getRangeToRend2[3];\n\n          this._callOnItemsRendered(_overscanStartIndex, _overscanStopIndex, _visibleStartIndex, _visibleStopIndex);\n        }\n      }\n\n      if (typeof this.props.onScroll === 'function') {\n        var _this$state2 = this.state,\n            _scrollDirection = _this$state2.scrollDirection,\n            _scrollOffset = _this$state2.scrollOffset,\n            _scrollUpdateWasRequested = _this$state2.scrollUpdateWasRequested;\n\n        this._callOnScroll(_scrollDirection, _scrollOffset, _scrollUpdateWasRequested);\n      }\n    }; // Lazily create and cache item styles while scrolling,\n    // So that pure component sCU will prevent re-renders.\n    // We maintain this cache, and pass a style prop rather than index,\n    // So that List can clear cached styles and force item re-render if necessary.\n\n\n    _proto._getRangeToRender = function _getRangeToRender() {\n      var _this$props5 = this.props,\n          itemCount = _this$props5.itemCount,\n          overscanCount = _this$props5.overscanCount;\n      var _this$state3 = this.state,\n          isScrolling = _this$state3.isScrolling,\n          scrollDirection = _this$state3.scrollDirection,\n          scrollOffset = _this$state3.scrollOffset;\n\n      if (itemCount === 0) {\n        return [0, 0, 0, 0];\n      }\n\n      var startIndex = getStartIndexForOffset(this.props, scrollOffset, this._instanceProps);\n      var stopIndex = getStopIndexForStartIndex(this.props, startIndex, scrollOffset, this._instanceProps); // Overscan by one item in each direction so that tab/focus works.\n      // If there isn't at least one extra item, tab loops back around.\n\n      var overscanBackward = !isScrolling || scrollDirection === 'backward' ? Math.max(1, overscanCount) : 1;\n      var overscanForward = !isScrolling || scrollDirection === 'forward' ? Math.max(1, overscanCount) : 1;\n      return [Math.max(0, startIndex - overscanBackward), Math.max(0, Math.min(itemCount - 1, stopIndex + overscanForward)), startIndex, stopIndex];\n    };\n\n    return List;\n  }(PureComponent), _class.defaultProps = {\n    direction: 'ltr',\n    itemData: undefined,\n    layout: 'vertical',\n    overscanCount: 2,\n    useIsScrolling: false\n  }, _temp;\n} // NOTE: I considered further wrapping individual items with a pure ListItem component.\n// This would avoid ever calling the render function for the same index more than once,\n// But it would also add the overhead of a lot of components/fibers.\n// I assume people already do this (render function returning a class component),\n// So my doing it would just unnecessarily double the wrappers.\n\nvar validateSharedProps$1 = function validateSharedProps(_ref2, _ref3) {\n  var children = _ref2.children,\n      direction = _ref2.direction,\n      height = _ref2.height,\n      layout = _ref2.layout,\n      innerTagName = _ref2.innerTagName,\n      outerTagName = _ref2.outerTagName,\n      width = _ref2.width;\n  var instance = _ref3.instance;\n\n  if (process.env.NODE_ENV !== 'production') {\n    if (innerTagName != null || outerTagName != null) {\n      if (devWarningsTagName$1 && !devWarningsTagName$1.has(instance)) {\n        devWarningsTagName$1.add(instance);\n        console.warn('The innerTagName and outerTagName props have been deprecated. ' + 'Please use the innerElementType and outerElementType props instead.');\n      }\n    } // TODO Deprecate direction \"horizontal\"\n\n\n    var isHorizontal = direction === 'horizontal' || layout === 'horizontal';\n\n    switch (direction) {\n      case 'horizontal':\n      case 'vertical':\n        if (devWarningsDirection && !devWarningsDirection.has(instance)) {\n          devWarningsDirection.add(instance);\n          console.warn('The direction prop should be either \"ltr\" (default) or \"rtl\". ' + 'Please use the layout prop to specify \"vertical\" (default) or \"horizontal\" orientation.');\n        }\n\n        break;\n\n      case 'ltr':\n      case 'rtl':\n        // Valid values\n        break;\n\n      default:\n        throw Error('An invalid \"direction\" prop has been specified. ' + 'Value should be either \"ltr\" or \"rtl\". ' + (\"\\\"\" + direction + \"\\\" was specified.\"));\n    }\n\n    switch (layout) {\n      case 'horizontal':\n      case 'vertical':\n        // Valid values\n        break;\n\n      default:\n        throw Error('An invalid \"layout\" prop has been specified. ' + 'Value should be either \"horizontal\" or \"vertical\". ' + (\"\\\"\" + layout + \"\\\" was specified.\"));\n    }\n\n    if (children == null) {\n      throw Error('An invalid \"children\" prop has been specified. ' + 'Value should be a React component. ' + (\"\\\"\" + (children === null ? 'null' : typeof children) + \"\\\" was specified.\"));\n    }\n\n    if (isHorizontal && typeof width !== 'number') {\n      throw Error('An invalid \"width\" prop has been specified. ' + 'Horizontal lists must specify a number for width. ' + (\"\\\"\" + (width === null ? 'null' : typeof width) + \"\\\" was specified.\"));\n    } else if (!isHorizontal && typeof height !== 'number') {\n      throw Error('An invalid \"height\" prop has been specified. ' + 'Vertical lists must specify a number for height. ' + (\"\\\"\" + (height === null ? 'null' : typeof height) + \"\\\" was specified.\"));\n    }\n  }\n};\n\nvar DEFAULT_ESTIMATED_ITEM_SIZE$1 = 50;\n\nvar getItemMetadata$1 = function getItemMetadata(props, index, instanceProps) {\n  var _ref = props,\n      itemSize = _ref.itemSize;\n  var itemMetadataMap = instanceProps.itemMetadataMap,\n      lastMeasuredIndex = instanceProps.lastMeasuredIndex;\n\n  if (index > lastMeasuredIndex) {\n    var offset = 0;\n\n    if (lastMeasuredIndex >= 0) {\n      var itemMetadata = itemMetadataMap[lastMeasuredIndex];\n      offset = itemMetadata.offset + itemMetadata.size;\n    }\n\n    for (var i = lastMeasuredIndex + 1; i <= index; i++) {\n      var size = itemSize(i);\n      itemMetadataMap[i] = {\n        offset: offset,\n        size: size\n      };\n      offset += size;\n    }\n\n    instanceProps.lastMeasuredIndex = index;\n  }\n\n  return itemMetadataMap[index];\n};\n\nvar findNearestItem$1 = function findNearestItem(props, instanceProps, offset) {\n  var itemMetadataMap = instanceProps.itemMetadataMap,\n      lastMeasuredIndex = instanceProps.lastMeasuredIndex;\n  var lastMeasuredItemOffset = lastMeasuredIndex > 0 ? itemMetadataMap[lastMeasuredIndex].offset : 0;\n\n  if (lastMeasuredItemOffset >= offset) {\n    // If we've already measured items within this range just use a binary search as it's faster.\n    return findNearestItemBinarySearch$1(props, instanceProps, lastMeasuredIndex, 0, offset);\n  } else {\n    // If we haven't yet measured this high, fallback to an exponential search with an inner binary search.\n    // The exponential search avoids pre-computing sizes for the full set of items as a binary search would.\n    // The overall complexity for this approach is O(log n).\n    return findNearestItemExponentialSearch$1(props, instanceProps, Math.max(0, lastMeasuredIndex), offset);\n  }\n};\n\nvar findNearestItemBinarySearch$1 = function findNearestItemBinarySearch(props, instanceProps, high, low, offset) {\n  while (low <= high) {\n    var middle = low + Math.floor((high - low) / 2);\n    var currentOffset = getItemMetadata$1(props, middle, instanceProps).offset;\n\n    if (currentOffset === offset) {\n      return middle;\n    } else if (currentOffset < offset) {\n      low = middle + 1;\n    } else if (currentOffset > offset) {\n      high = middle - 1;\n    }\n  }\n\n  if (low > 0) {\n    return low - 1;\n  } else {\n    return 0;\n  }\n};\n\nvar findNearestItemExponentialSearch$1 = function findNearestItemExponentialSearch(props, instanceProps, index, offset) {\n  var itemCount = props.itemCount;\n  var interval = 1;\n\n  while (index < itemCount && getItemMetadata$1(props, index, instanceProps).offset < offset) {\n    index += interval;\n    interval *= 2;\n  }\n\n  return findNearestItemBinarySearch$1(props, instanceProps, Math.min(index, itemCount - 1), Math.floor(index / 2), offset);\n};\n\nvar getEstimatedTotalSize = function getEstimatedTotalSize(_ref2, _ref3) {\n  var itemCount = _ref2.itemCount;\n  var itemMetadataMap = _ref3.itemMetadataMap,\n      estimatedItemSize = _ref3.estimatedItemSize,\n      lastMeasuredIndex = _ref3.lastMeasuredIndex;\n  var totalSizeOfMeasuredItems = 0; // Edge case check for when the number of items decreases while a scroll is in progress.\n  // https://github.com/bvaughn/react-window/pull/138\n\n  if (lastMeasuredIndex >= itemCount) {\n    lastMeasuredIndex = itemCount - 1;\n  }\n\n  if (lastMeasuredIndex >= 0) {\n    var itemMetadata = itemMetadataMap[lastMeasuredIndex];\n    totalSizeOfMeasuredItems = itemMetadata.offset + itemMetadata.size;\n  }\n\n  var numUnmeasuredItems = itemCount - lastMeasuredIndex - 1;\n  var totalSizeOfUnmeasuredItems = numUnmeasuredItems * estimatedItemSize;\n  return totalSizeOfMeasuredItems + totalSizeOfUnmeasuredItems;\n};\n\nvar VariableSizeList =\n/*#__PURE__*/\ncreateListComponent({\n  getItemOffset: function getItemOffset(props, index, instanceProps) {\n    return getItemMetadata$1(props, index, instanceProps).offset;\n  },\n  getItemSize: function getItemSize(props, index, instanceProps) {\n    return instanceProps.itemMetadataMap[index].size;\n  },\n  getEstimatedTotalSize: getEstimatedTotalSize,\n  getOffsetForIndexAndAlignment: function getOffsetForIndexAndAlignment(props, index, align, scrollOffset, instanceProps) {\n    var direction = props.direction,\n        height = props.height,\n        layout = props.layout,\n        width = props.width; // TODO Deprecate direction \"horizontal\"\n\n    var isHorizontal = direction === 'horizontal' || layout === 'horizontal';\n    var size = isHorizontal ? width : height;\n    var itemMetadata = getItemMetadata$1(props, index, instanceProps); // Get estimated total size after ItemMetadata is computed,\n    // To ensure it reflects actual measurements instead of just estimates.\n\n    var estimatedTotalSize = getEstimatedTotalSize(props, instanceProps);\n    var maxOffset = Math.max(0, Math.min(estimatedTotalSize - size, itemMetadata.offset));\n    var minOffset = Math.max(0, itemMetadata.offset - size + itemMetadata.size);\n\n    if (align === 'smart') {\n      if (scrollOffset >= minOffset - size && scrollOffset <= maxOffset + size) {\n        align = 'auto';\n      } else {\n        align = 'center';\n      }\n    }\n\n    switch (align) {\n      case 'start':\n        return maxOffset;\n\n      case 'end':\n        return minOffset;\n\n      case 'center':\n        return Math.round(minOffset + (maxOffset - minOffset) / 2);\n\n      case 'auto':\n      default:\n        if (scrollOffset >= minOffset && scrollOffset <= maxOffset) {\n          return scrollOffset;\n        } else if (scrollOffset < minOffset) {\n          return minOffset;\n        } else {\n          return maxOffset;\n        }\n\n    }\n  },\n  getStartIndexForOffset: function getStartIndexForOffset(props, offset, instanceProps) {\n    return findNearestItem$1(props, instanceProps, offset);\n  },\n  getStopIndexForStartIndex: function getStopIndexForStartIndex(props, startIndex, scrollOffset, instanceProps) {\n    var direction = props.direction,\n        height = props.height,\n        itemCount = props.itemCount,\n        layout = props.layout,\n        width = props.width; // TODO Deprecate direction \"horizontal\"\n\n    var isHorizontal = direction === 'horizontal' || layout === 'horizontal';\n    var size = isHorizontal ? width : height;\n    var itemMetadata = getItemMetadata$1(props, startIndex, instanceProps);\n    var maxOffset = scrollOffset + size;\n    var offset = itemMetadata.offset + itemMetadata.size;\n    var stopIndex = startIndex;\n\n    while (stopIndex < itemCount - 1 && offset < maxOffset) {\n      stopIndex++;\n      offset += getItemMetadata$1(props, stopIndex, instanceProps).size;\n    }\n\n    return stopIndex;\n  },\n  initInstanceProps: function initInstanceProps(props, instance) {\n    var _ref4 = props,\n        estimatedItemSize = _ref4.estimatedItemSize;\n    var instanceProps = {\n      itemMetadataMap: {},\n      estimatedItemSize: estimatedItemSize || DEFAULT_ESTIMATED_ITEM_SIZE$1,\n      lastMeasuredIndex: -1\n    };\n\n    instance.resetAfterIndex = function (index, shouldForceUpdate) {\n      if (shouldForceUpdate === void 0) {\n        shouldForceUpdate = true;\n      }\n\n      instanceProps.lastMeasuredIndex = Math.min(instanceProps.lastMeasuredIndex, index - 1); // We could potentially optimize further by only evicting styles after this index,\n      // But since styles are only cached while scrolling is in progress-\n      // It seems an unnecessary optimization.\n      // It's unlikely that resetAfterIndex() will be called while a user is scrolling.\n\n      instance._getItemStyleCache(-1);\n\n      if (shouldForceUpdate) {\n        instance.forceUpdate();\n      }\n    };\n\n    return instanceProps;\n  },\n  shouldResetStyleCacheOnItemSizeChange: false,\n  validateProps: function validateProps(_ref5) {\n    var itemSize = _ref5.itemSize;\n\n    if (process.env.NODE_ENV !== 'production') {\n      if (typeof itemSize !== 'function') {\n        throw Error('An invalid \"itemSize\" prop has been specified. ' + 'Value should be a function. ' + (\"\\\"\" + (itemSize === null ? 'null' : typeof itemSize) + \"\\\" was specified.\"));\n      }\n    }\n  }\n});\n\nvar FixedSizeGrid =\n/*#__PURE__*/\ncreateGridComponent({\n  getColumnOffset: function getColumnOffset(_ref, index) {\n    var columnWidth = _ref.columnWidth;\n    return index * columnWidth;\n  },\n  getColumnWidth: function getColumnWidth(_ref2, index) {\n    var columnWidth = _ref2.columnWidth;\n    return columnWidth;\n  },\n  getRowOffset: function getRowOffset(_ref3, index) {\n    var rowHeight = _ref3.rowHeight;\n    return index * rowHeight;\n  },\n  getRowHeight: function getRowHeight(_ref4, index) {\n    var rowHeight = _ref4.rowHeight;\n    return rowHeight;\n  },\n  getEstimatedTotalHeight: function getEstimatedTotalHeight(_ref5) {\n    var rowCount = _ref5.rowCount,\n        rowHeight = _ref5.rowHeight;\n    return rowHeight * rowCount;\n  },\n  getEstimatedTotalWidth: function getEstimatedTotalWidth(_ref6) {\n    var columnCount = _ref6.columnCount,\n        columnWidth = _ref6.columnWidth;\n    return columnWidth * columnCount;\n  },\n  getOffsetForColumnAndAlignment: function getOffsetForColumnAndAlignment(_ref7, columnIndex, align, scrollLeft, instanceProps, scrollbarSize) {\n    var columnCount = _ref7.columnCount,\n        columnWidth = _ref7.columnWidth,\n        width = _ref7.width;\n    var lastColumnOffset = Math.max(0, columnCount * columnWidth - width);\n    var maxOffset = Math.min(lastColumnOffset, columnIndex * columnWidth);\n    var minOffset = Math.max(0, columnIndex * columnWidth - width + scrollbarSize + columnWidth);\n\n    if (align === 'smart') {\n      if (scrollLeft >= minOffset - width && scrollLeft <= maxOffset + width) {\n        align = 'auto';\n      } else {\n        align = 'center';\n      }\n    }\n\n    switch (align) {\n      case 'start':\n        return maxOffset;\n\n      case 'end':\n        return minOffset;\n\n      case 'center':\n        // \"Centered\" offset is usually the average of the min and max.\n        // But near the edges of the list, this doesn't hold true.\n        var middleOffset = Math.round(minOffset + (maxOffset - minOffset) / 2);\n\n        if (middleOffset < Math.ceil(width / 2)) {\n          return 0; // near the beginning\n        } else if (middleOffset > lastColumnOffset + Math.floor(width / 2)) {\n          return lastColumnOffset; // near the end\n        } else {\n          return middleOffset;\n        }\n\n      case 'auto':\n      default:\n        if (scrollLeft >= minOffset && scrollLeft <= maxOffset) {\n          return scrollLeft;\n        } else if (minOffset > maxOffset) {\n          // Because we only take into account the scrollbar size when calculating minOffset\n          // this value can be larger than maxOffset when at the end of the list\n          return minOffset;\n        } else if (scrollLeft < minOffset) {\n          return minOffset;\n        } else {\n          return maxOffset;\n        }\n\n    }\n  },\n  getOffsetForRowAndAlignment: function getOffsetForRowAndAlignment(_ref8, rowIndex, align, scrollTop, instanceProps, scrollbarSize) {\n    var rowHeight = _ref8.rowHeight,\n        height = _ref8.height,\n        rowCount = _ref8.rowCount;\n    var lastRowOffset = Math.max(0, rowCount * rowHeight - height);\n    var maxOffset = Math.min(lastRowOffset, rowIndex * rowHeight);\n    var minOffset = Math.max(0, rowIndex * rowHeight - height + scrollbarSize + rowHeight);\n\n    if (align === 'smart') {\n      if (scrollTop >= minOffset - height && scrollTop <= maxOffset + height) {\n        align = 'auto';\n      } else {\n        align = 'center';\n      }\n    }\n\n    switch (align) {\n      case 'start':\n        return maxOffset;\n\n      case 'end':\n        return minOffset;\n\n      case 'center':\n        // \"Centered\" offset is usually the average of the min and max.\n        // But near the edges of the list, this doesn't hold true.\n        var middleOffset = Math.round(minOffset + (maxOffset - minOffset) / 2);\n\n        if (middleOffset < Math.ceil(height / 2)) {\n          return 0; // near the beginning\n        } else if (middleOffset > lastRowOffset + Math.floor(height / 2)) {\n          return lastRowOffset; // near the end\n        } else {\n          return middleOffset;\n        }\n\n      case 'auto':\n      default:\n        if (scrollTop >= minOffset && scrollTop <= maxOffset) {\n          return scrollTop;\n        } else if (minOffset > maxOffset) {\n          // Because we only take into account the scrollbar size when calculating minOffset\n          // this value can be larger than maxOffset when at the end of the list\n          return minOffset;\n        } else if (scrollTop < minOffset) {\n          return minOffset;\n        } else {\n          return maxOffset;\n        }\n\n    }\n  },\n  getColumnStartIndexForOffset: function getColumnStartIndexForOffset(_ref9, scrollLeft) {\n    var columnWidth = _ref9.columnWidth,\n        columnCount = _ref9.columnCount;\n    return Math.max(0, Math.min(columnCount - 1, Math.floor(scrollLeft / columnWidth)));\n  },\n  getColumnStopIndexForStartIndex: function getColumnStopIndexForStartIndex(_ref10, startIndex, scrollLeft) {\n    var columnWidth = _ref10.columnWidth,\n        columnCount = _ref10.columnCount,\n        width = _ref10.width;\n    var left = startIndex * columnWidth;\n    var numVisibleColumns = Math.ceil((width + scrollLeft - left) / columnWidth);\n    return Math.max(0, Math.min(columnCount - 1, startIndex + numVisibleColumns - 1 // -1 is because stop index is inclusive\n    ));\n  },\n  getRowStartIndexForOffset: function getRowStartIndexForOffset(_ref11, scrollTop) {\n    var rowHeight = _ref11.rowHeight,\n        rowCount = _ref11.rowCount;\n    return Math.max(0, Math.min(rowCount - 1, Math.floor(scrollTop / rowHeight)));\n  },\n  getRowStopIndexForStartIndex: function getRowStopIndexForStartIndex(_ref12, startIndex, scrollTop) {\n    var rowHeight = _ref12.rowHeight,\n        rowCount = _ref12.rowCount,\n        height = _ref12.height;\n    var top = startIndex * rowHeight;\n    var numVisibleRows = Math.ceil((height + scrollTop - top) / rowHeight);\n    return Math.max(0, Math.min(rowCount - 1, startIndex + numVisibleRows - 1 // -1 is because stop index is inclusive\n    ));\n  },\n  initInstanceProps: function initInstanceProps(props) {// Noop\n  },\n  shouldResetStyleCacheOnItemSizeChange: true,\n  validateProps: function validateProps(_ref13) {\n    var columnWidth = _ref13.columnWidth,\n        rowHeight = _ref13.rowHeight;\n\n    if (process.env.NODE_ENV !== 'production') {\n      if (typeof columnWidth !== 'number') {\n        throw Error('An invalid \"columnWidth\" prop has been specified. ' + 'Value should be a number. ' + (\"\\\"\" + (columnWidth === null ? 'null' : typeof columnWidth) + \"\\\" was specified.\"));\n      }\n\n      if (typeof rowHeight !== 'number') {\n        throw Error('An invalid \"rowHeight\" prop has been specified. ' + 'Value should be a number. ' + (\"\\\"\" + (rowHeight === null ? 'null' : typeof rowHeight) + \"\\\" was specified.\"));\n      }\n    }\n  }\n});\n\nvar FixedSizeList =\n/*#__PURE__*/\ncreateListComponent({\n  getItemOffset: function getItemOffset(_ref, index) {\n    var itemSize = _ref.itemSize;\n    return index * itemSize;\n  },\n  getItemSize: function getItemSize(_ref2, index) {\n    var itemSize = _ref2.itemSize;\n    return itemSize;\n  },\n  getEstimatedTotalSize: function getEstimatedTotalSize(_ref3) {\n    var itemCount = _ref3.itemCount,\n        itemSize = _ref3.itemSize;\n    return itemSize * itemCount;\n  },\n  getOffsetForIndexAndAlignment: function getOffsetForIndexAndAlignment(_ref4, index, align, scrollOffset) {\n    var direction = _ref4.direction,\n        height = _ref4.height,\n        itemCount = _ref4.itemCount,\n        itemSize = _ref4.itemSize,\n        layout = _ref4.layout,\n        width = _ref4.width;\n    // TODO Deprecate direction \"horizontal\"\n    var isHorizontal = direction === 'horizontal' || layout === 'horizontal';\n    var size = isHorizontal ? width : height;\n    var lastItemOffset = Math.max(0, itemCount * itemSize - size);\n    var maxOffset = Math.min(lastItemOffset, index * itemSize);\n    var minOffset = Math.max(0, index * itemSize - size + itemSize);\n\n    if (align === 'smart') {\n      if (scrollOffset >= minOffset - size && scrollOffset <= maxOffset + size) {\n        align = 'auto';\n      } else {\n        align = 'center';\n      }\n    }\n\n    switch (align) {\n      case 'start':\n        return maxOffset;\n\n      case 'end':\n        return minOffset;\n\n      case 'center':\n        {\n          // \"Centered\" offset is usually the average of the min and max.\n          // But near the edges of the list, this doesn't hold true.\n          var middleOffset = Math.round(minOffset + (maxOffset - minOffset) / 2);\n\n          if (middleOffset < Math.ceil(size / 2)) {\n            return 0; // near the beginning\n          } else if (middleOffset > lastItemOffset + Math.floor(size / 2)) {\n            return lastItemOffset; // near the end\n          } else {\n            return middleOffset;\n          }\n        }\n\n      case 'auto':\n      default:\n        if (scrollOffset >= minOffset && scrollOffset <= maxOffset) {\n          return scrollOffset;\n        } else if (scrollOffset < minOffset) {\n          return minOffset;\n        } else {\n          return maxOffset;\n        }\n\n    }\n  },\n  getStartIndexForOffset: function getStartIndexForOffset(_ref5, offset) {\n    var itemCount = _ref5.itemCount,\n        itemSize = _ref5.itemSize;\n    return Math.max(0, Math.min(itemCount - 1, Math.floor(offset / itemSize)));\n  },\n  getStopIndexForStartIndex: function getStopIndexForStartIndex(_ref6, startIndex, scrollOffset) {\n    var direction = _ref6.direction,\n        height = _ref6.height,\n        itemCount = _ref6.itemCount,\n        itemSize = _ref6.itemSize,\n        layout = _ref6.layout,\n        width = _ref6.width;\n    // TODO Deprecate direction \"horizontal\"\n    var isHorizontal = direction === 'horizontal' || layout === 'horizontal';\n    var offset = startIndex * itemSize;\n    var size = isHorizontal ? width : height;\n    var numVisibleItems = Math.ceil((size + scrollOffset - offset) / itemSize);\n    return Math.max(0, Math.min(itemCount - 1, startIndex + numVisibleItems - 1 // -1 is because stop index is inclusive\n    ));\n  },\n  initInstanceProps: function initInstanceProps(props) {// Noop\n  },\n  shouldResetStyleCacheOnItemSizeChange: true,\n  validateProps: function validateProps(_ref7) {\n    var itemSize = _ref7.itemSize;\n\n    if (process.env.NODE_ENV !== 'production') {\n      if (typeof itemSize !== 'number') {\n        throw Error('An invalid \"itemSize\" prop has been specified. ' + 'Value should be a number. ' + (\"\\\"\" + (itemSize === null ? 'null' : typeof itemSize) + \"\\\" was specified.\"));\n      }\n    }\n  }\n});\n\n// Pulled from react-compat\n// https://github.com/developit/preact-compat/blob/7c5de00e7c85e2ffd011bf3af02899b63f699d3a/src/index.js#L349\nfunction shallowDiffers(prev, next) {\n  for (var attribute in prev) {\n    if (!(attribute in next)) {\n      return true;\n    }\n  }\n\n  for (var _attribute in next) {\n    if (prev[_attribute] !== next[_attribute]) {\n      return true;\n    }\n  }\n\n  return false;\n}\n\n// It knows to compare individual style props and ignore the wrapper object.\n// See https://reactjs.org/docs/react-api.html#reactmemo\n\nfunction areEqual(prevProps, nextProps) {\n  var prevStyle = prevProps.style,\n      prevRest = _objectWithoutPropertiesLoose(prevProps, [\"style\"]);\n\n  var nextStyle = nextProps.style,\n      nextRest = _objectWithoutPropertiesLoose(nextProps, [\"style\"]);\n\n  return !shallowDiffers(prevStyle, nextStyle) && !shallowDiffers(prevRest, nextRest);\n}\n\n// It knows to compare individual style props and ignore the wrapper object.\n// See https://reactjs.org/docs/react-component.html#shouldcomponentupdate\n\nfunction shouldComponentUpdate(nextProps, nextState) {\n  return !areEqual(this.props, nextProps) || shallowDiffers(this.state, nextState);\n}\n\nexport { VariableSizeGrid, VariableSizeList, FixedSizeGrid, FixedSizeList, areEqual, shouldComponentUpdate };\n//# sourceMappingURL=index.esm.js.map\n"],"sourceRoot":""}